import io
import typing
from unittest.mock import Mock

import pytest
from httpx import HTTPStatusError
from pycelonis_core.base.base_model import PyCelonisBaseModel
from pycelonis_core.client.response_processor import ResponseProcessor
from pycelonis_core.utils.errors import (
    PyCelonisHTTPStatusError,
    PyCelonisNotFoundError,
    PyCelonisPermissionError,
    PyCelonisValueError,
)


class TestResponseProcessor:
    @pytest.mark.parametrize(
        "status_code",
        [401, 403],
    )
    def test_response_with_status_code_401_and_403_raises_permission_error(self, status_code):
        response_mock = Mock()
        response_mock.status_code = status_code

        with pytest.raises(PyCelonisPermissionError):
            ResponseProcessor().process(response_mock)

    def test_response_with_status_code_404_raises_not_found_error(self):
        response_mock = Mock()
        response_mock.status_code = 404

        with pytest.raises(PyCelonisNotFoundError):
            ResponseProcessor().process(response_mock)

    def test_response_with_status_code_500_raises_http_status_error(self):
        response_mock = Mock()
        request_mock = Mock()
        response_mock.raise_for_status = Mock(
            side_effect=HTTPStatusError("ERROR", request=request_mock, response=response_mock)
        )

        with pytest.raises(PyCelonisHTTPStatusError):
            ResponseProcessor().process(response_mock)

    def test_parse_base_model_response_returns_object(self):
        class PyCelonisBaseModelTest(PyCelonisBaseModel):
            name: typing.Optional[str]

        NAME = "TEST_NAME"
        response_mock = Mock()
        response_mock.json = Mock(return_value={"name": NAME})
        response_mock.headers = {"content-type": "application/json"}

        response = ResponseProcessor().process(response_mock, type_=PyCelonisBaseModelTest, parse_json=True)

        assert response == PyCelonisBaseModelTest(name=NAME)

    def test_do_not_parse_response_returns_response_object(self):
        response_mock = Mock()

        response = ResponseProcessor().process(response_mock, parse_json=False)

        assert response == response_mock

    def test_parse_base_model_response_returns_dict_if_no_type_given(self):
        NAME = "TEST_NAME"
        response_value = {"name": NAME}
        response_mock = Mock()
        response_mock.json = Mock(return_value=response_value)
        response_mock.headers = {"content-type": "application/json"}

        response = ResponseProcessor().process(response_mock, parse_json=True)

        assert response == response_value

    def test_parse_base_model_response_without_json_raises_error(self):
        class PyCelonisBaseModelTest(PyCelonisBaseModel):
            name: typing.Optional[str]

        response_mock = Mock()
        response_mock.json = Mock(return_value={})
        response_mock.headers = {"Content-Type": "application/csv"}

        with pytest.raises(PyCelonisValueError):
            ResponseProcessor().process(response_mock, type_=PyCelonisBaseModelTest, parse_json=True)

    def test_parse_empty_response_returns_none(self):
        response_mock = Mock()
        response_mock.content = b""

        response = ResponseProcessor().process(response_mock, parse_json=True)

        assert response is None

    def test_parse_byte_response_returns_bytes_io(self):
        response_mock = Mock()
        response_content = b"test_response"
        response_mock.content = response_content

        response = ResponseProcessor().process(response_mock, parse_json=True, type_=io.BytesIO)

        with io.BytesIO(response_content) as expected_response:
            assert response.read() == expected_response.read()
