import os
import re
import ssl
from unittest.mock import patch

import httpx
import pycelonis
import pytest
from packaging.version import parse
from pycelonis import _get_latest_version, get_celonis
from pycelonis.celonis import Celonis
from pycelonis_core.client import KeyType


@pytest.mark.vcr()
class TestGetCelonis:
    def test_check_if_outdated(self):
        response = httpx.get("https://pypi.celonis.cloud/pycelonis/")
        versions = re.findall(r"pycelonis-([0-9]+\.[0-9]+\.[0-9]+).tar.gz<", response.text)
        parsed_versions = [parse(v) for v in versions]

        assert _get_latest_version() == max(parsed_versions)
        assert len(versions) > 1

    @patch.dict(os.environ, {"OAUTH_SCOPES": "", "OAUTH_CLIENT_ID": "", "OAUTH_CLIENT_SECRET": ""})
    def test_get_celonis_connect_is_true(self):
        celonis = get_celonis(connect=True, permissions=False)

        assert isinstance(celonis, Celonis)

    def test_get_celonis_connect_is_false(self):
        celonis = get_celonis(connect=False, permissions=False)

        assert isinstance(celonis, Celonis)

    def test_get_celonis_key_type_not_specified(self):
        celonis = get_celonis(permissions=False)

        assert isinstance(celonis, Celonis)

    def test_get_celonis_verify_ssl_enabled(self):
        celonis = get_celonis(verify_ssl=True)
        assert isinstance(celonis, Celonis)
        assert celonis.client._client._transport._pool._ssl_context.verify_mode == ssl.CERT_REQUIRED

    @patch.object(pycelonis.TeamService, "get_api_cloud", lambda client: None)
    @patch("pycelonis._is_tracking_disabled")
    def test_get_celonis_verify_ssl_enabled_with_proxy(self, _is_tracking_disabled_mock):
        _is_tracking_disabled_mock.return_value = False
        celonis = get_celonis(verify_ssl=True, proxy="http://localhost:8031", connect=False, permissions=False)
        assert next(iter(celonis.client.client._mounts.values()))._pool._ssl_context.verify_mode == ssl.CERT_REQUIRED

    def test_get_celonis_verify_ssl_disabled(self):
        celonis = get_celonis(verify_ssl=False)
        assert isinstance(celonis, Celonis)
        assert celonis.client._client._transport._pool._ssl_context.verify_mode == ssl.CERT_NONE

    @patch.object(pycelonis.TeamService, "get_api_cloud", lambda client: None)
    @patch("pycelonis._is_tracking_disabled")
    def test_get_celonis_verify_ssl_disabled_with_proxy(self, _is_tracking_disabled_mock):
        _is_tracking_disabled_mock.return_value = False
        celonis = get_celonis(verify_ssl=False, proxy="http://localhost:8031", connect=False, permissions=False)
        assert next(iter(celonis.client.client._mounts.values()))._pool._ssl_context.verify_mode == ssl.CERT_NONE

    @patch.dict(os.environ, {"CELONIS_API_TOKEN": ""})
    def test_get_celonis_oauth(self):
        celonis = pycelonis.get_celonis(key_type=KeyType.BEARER)

        assert isinstance(celonis, Celonis)

    @pytest.mark.skipif(
        "config.getoption('--disable-vcr')",
        reason="Only run when vcr is enabled as env variables point to auth credentials with basic authentication.",
    )
    @patch.dict(os.environ, {"CELONIS_API_TOKEN": "", "OAUTH_METHOD": "POST"})
    def test_get_celonis_oauth_post(self):
        celonis = pycelonis.get_celonis(key_type=KeyType.BEARER)

        assert isinstance(celonis, Celonis)

    def test_get_celonis_with_mounts(self):
        celonis = get_celonis(mounts={"http://": httpx.HTTPTransport(proxy="http://localhost:8031")})
        assert isinstance(celonis, Celonis)

    def test_get_celonis_1p(self, access_token_file):
        with patch.dict(
            "os.environ",
            {
                "CELONIS_API_TOKEN": "",
                "OAUTH_SCOPES": "",
                "OAUTH_CLIENT_ID": "",
                "OAUTH_CLIENT_SECRET": "",
                "OAUTH_ACCESS_TOKEN_PATH": str(access_token_file),
            },
        ):
            celonis = get_celonis()

        assert isinstance(celonis, Celonis)
